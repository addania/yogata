{"componentChunkName":"component---src-templates-blog-post-js","path":"/Function_vs_Arrow_and_Hoisting/","result":{"data":{"markdownRemark":{"html":"<p>If we use function definition like this (using arrow functions):</p>\n<pre><code>const Button = () => {\n}\n</code></pre>\n<p>and this definition is AFTER code where it is called, it might still not be defined.</p>\n<p>But if we use:</p>\n<pre><code> function Button () {\n}\n</code></pre>\n<p>such function definition can be anywhere at the end of the file, but it will be <strong>HOISTED</strong>. </p>\n<p>Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.</p>\n<p>Inevitably, this means that no matter where functions and variables are declared, they are moved to the top of their scope regardless of whether their scope is global or local. </p>\n<p>This allows you to  be able to call functions before you wrote them in your code.</p>\n<blockquote>\n<p>Reference:</p>\n</blockquote>\n<p><a href=\"https://scotch.io/tutorials/understanding-hoisting-in-javascript\">https://scotch.io/tutorials/understanding-hoisting-in-javascript</a></p>","frontmatter":{"title":"Function definition: Arrow vs Function, Hoising"},"excerpt":"If we use function definition like this (using arrow functions): and this definition is AFTER code where it is called, it might still not beâ€¦"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Function_vs_Arrow_and_Hoisting/"}}}